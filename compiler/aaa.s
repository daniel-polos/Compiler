;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

;;; here we REServe enough Quad-words (64-bit "cells") for the free variables
;;; each free variable has 8 bytes reserved for a 64-bit pointer to its value
fvar_tbl:
    resq 51

section .data
const_tbl:
db T_VOID
db T_NIL
db T_BOOL, 0
db T_BOOL, 1
MAKE_LITERAL_STRING"whatever"
MAKE_LITERAL_SYMBOL(const_tbl+6)
MAKE_LITERAL_RATIONAL(0,1)
MAKE_LITERAL_RATIONAL(1,1)
MAKE_LITERAL_RATIONAL(-1,1)
MAKE_LITERAL_STRING"a"
MAKE_LITERAL_SYMBOL(const_tbl+83)

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4

global main
section .text
main:
    ;; set up the heap
    mov rdi, GB(2)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0                ; argument count
    push SOB_NIL_ADDRESS  ; lexical environment address
    push T_UNDEFINED      ; return address
    push rbp                    
    mov rbp, rsp                ; anchor the dummy frame

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we simulate the missing (define ...) expressions
    ;; for all the primitive procedures.
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, boolean?)
mov qword[fvar_tbl+0*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, flonum?)
mov qword[fvar_tbl+1*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, rational?)
mov qword[fvar_tbl+2*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, pair?)
mov qword[fvar_tbl+3*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, null?)
mov qword[fvar_tbl+4*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char?)
mov qword[fvar_tbl+5*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string?)
mov qword[fvar_tbl+6*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, procedure?)
mov qword[fvar_tbl+7*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol?)
mov qword[fvar_tbl+8*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
mov qword[fvar_tbl+9*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
mov qword[fvar_tbl+10*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
mov qword[fvar_tbl+11*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
mov qword[fvar_tbl+12*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
mov qword[fvar_tbl+13*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
mov qword[fvar_tbl+14*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
mov qword[fvar_tbl+15*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, exact_to_inexact)
mov qword[fvar_tbl+16*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq?)
mov qword[fvar_tbl+17*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, add)
mov qword[fvar_tbl+18*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, mul)
mov qword[fvar_tbl+19*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, div)
mov qword[fvar_tbl+20*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq)
mov qword[fvar_tbl+21*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, lt)
mov qword[fvar_tbl+22*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, numerator)
mov qword[fvar_tbl+23*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, denominator)
mov qword[fvar_tbl+24*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, gcd)
mov qword[fvar_tbl+25*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, apply)
mov qword[fvar_tbl+26*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
mov qword[fvar_tbl+27*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
mov qword[fvar_tbl+28*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons)
mov qword[fvar_tbl+29*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_car)
mov qword[fvar_tbl+30*WORD_SIZE], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_cdr)
mov qword[fvar_tbl+31*WORD_SIZE], rax

user_code_fragment:
;;; The code you compiled will be added here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.
;create Def: 
;create Set for varFree map:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a free param: apply
 mov rax, qword [fvar_tbl+ WORD_SIZE*26]
push rax
; create a free param: cons
 mov rax, qword [fvar_tbl+ WORD_SIZE*29]
push rax
; create a free param: cdr
 mov rax, qword [fvar_tbl+ WORD_SIZE*28]
push rax
; create a free param: car
 mov rax, qword [fvar_tbl+ WORD_SIZE*27]
push rax
; create a free param: null?
 mov rax, qword [fvar_tbl+ WORD_SIZE*4]
push rax

Noa1:
mov r10, 5;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple first layer:
    MAKE_CLOSURE(rax,  SOB_NIL_ADDRESS, Lcode2)
    ;jump beyond the Body
    jmp Lcont2
    Lcode2:
    push rbp
    mov rbp, rsp
    ;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a const
mov rax, const_tbl+23
push rax
; create a const
mov rax, const_tbl+23
push rax

Noa3:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*2
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking4:
mov rcx, 0 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env4 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop4:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop4
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env4:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check14:
cmp rcx, 0
je Continue_Allocate_Closure_Object4
check24:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop4:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop4
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object4:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode4)
;jump beyond the Body
jmp Lcont4
Lcode4:
push rbp
mov rbp, rsp
;create a seq:
;create Set for varParam map-many:
;create a Box:
MALLOC r8, WORD_SIZE
; create a varParam: map-many
 mov rax, PVAR(0)

mov qword [r8], rax
mov rax, r8
mov PVAR(0), rax
 mov rax, SOB_VOID_ADDRESS
;create Set for varParam map-one:
;create a Box:
MALLOC r8, WORD_SIZE
; create a varParam: map-one
 mov rax, PVAR(1)

mov qword [r8], rax
mov rax, r8
mov PVAR(1), rax
 mov rax, SOB_VOID_ADDRESS
;create BoxSet :
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking5:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env5 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop5:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop5
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env5:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check15:
cmp rcx, 0
je Continue_Allocate_Closure_Object5
check25:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop5:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop5
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object5:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode5)
;jump beyond the Body
jmp Lcont5
Lcode5:
push rbp
mov rbp, rsp
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: lists
 mov rax, PVAR(1)
push rax

Noa13:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: car
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*1]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa12:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: null?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse6
; create a const
mov rax, const_tbl+1
jmp lexit6
lelse6:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: lists
 mov rax, PVAR(1)
push rax
; create a bound param: cdr
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*2]
push rax

Noa11:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create BoxGet :
; create a bound param: map-one
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*1]
mov rax, qword[rax]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
; create a varParam: f
 mov rax, PVAR(0)
push rax

Noa10:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create BoxGet :
; create a bound param: map-many
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]
mov rax, qword[rax]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: lists
 mov rax, PVAR(1)
push rax
; create a bound param: car
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*1]
push rax

Noa9:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create BoxGet :
; create a bound param: map-one
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*1]
mov rax, qword[rax]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
; create a varParam: f
 mov rax, PVAR(0)
push rax

Noa8:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: apply
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*4]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa7:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: cons
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*3]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
lexit6:

leave
ret
;end of the body (closure)
Lcont5:
push rax
; create a varParam: map-many
 mov rax, PVAR(0)
pop qword[rax]
mov rax, SOB_VOID_ADDRESS
;create BoxSet :
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking14:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env14 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop14:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop14
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env14:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check114:
cmp rcx, 0
je Continue_Allocate_Closure_Object14
check214:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop14:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop14
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object14:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode14)
;jump beyond the Body
jmp Lcont14
Lcode14:
push rbp
mov rbp, rsp
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: s
 mov rax, PVAR(1)
push rax

Noa21:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: null?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse15
; create a const
mov rax, const_tbl+1
jmp lexit15
lelse15:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: s
 mov rax, PVAR(1)
push rax

Noa20:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: cdr
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*2]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
; create a varParam: f
 mov rax, PVAR(0)
push rax

Noa19:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create BoxGet :
; create a bound param: map-one
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*1]
mov rax, qword[rax]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: s
 mov rax, PVAR(1)
push rax

Noa18:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: car
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*1]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa17:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a varParam: f
 mov rax, PVAR(0)

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa16:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: cons
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*3]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
lexit15:

leave
ret
;end of the body (closure)
Lcont14:
push rax
; create a varParam: map-one
 mov rax, PVAR(1)
pop qword[rax]
mov rax, SOB_VOID_ADDRESS
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic

Noa22:
mov r10, 0;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking23:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env23 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop23:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop23
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env23:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check123:
cmp rcx, 0
je Continue_Allocate_Closure_Object23
check223:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop23:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop23
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object23:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode23)
;jump beyond the Body
jmp Lcont23
Lcode23:
push rbp
mov rbp, rsp
;create LambdaOpt multiple layers:
;code for_ext env
MALLOC rdx, WORD_SIZE*4
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking24:
mov rcx, 2 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env24 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop24:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop24
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env24:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check124:
cmp rcx, 0
je Continue_Allocate_Closure_Object24
check224:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop24:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop24
Continue_Allocate_Closure_Object24:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode24)
;jump beyond the Body
jmp Lcont24
Lcode24:
push rbp
mov rbp, rsp
mov rbx, qword[rbp+ 8*3] ; rbp=n (num of initial params)
mov r8, 1 ; r8= num of must params
cmp rbx, r8 ;comparing the numbers of params with the number of the must params 
je Cont_After_Adjust24
;now code to adjust the params 
mov rcx, rbx ; ecx in now num of params 
sub rcx, r8; ecx now is num of iterations=> (num of params)- (num of must params)
add rbx, 3  ; 
shl rbx,  3 ; mutiply (n+3)*8-> distance from the An to rbx
mov r9, [rbp+rbx] ;r9=A0
mov r10, [rbp+rbx+WORD_SIZE] ;r10 holds the magic
MAKE_PAIR(r11, r9, r10) ; r11 now point to the pair(An, SOB_NIl_ADDRESS
sub rcx, 1 ; one less iteraition
cmp rcx, 0
je Cont_after_r11_list24
sub rbx, WORD_SIZE
Loop_Make_List24:
;Looop invariant r11 always points to the last Pair
mov r8, r11 ; now r8 point to the last Pair
mov r9, [rbp+rbx]; r9 point to A(i-1)
MAKE_PAIR(r11, r9,r8)
sub rbx, WORD_SIZE
loop Loop_Make_List24
Cont_after_r11_list24:
;now r11 point to the Pairs. to the list
mov qword [rbp + (4+1)*8], r11 ;the pointer to the list is right above the last must params
mov qword [rbp + (4+2)*8], SOB_NIL_ADDRESS ; magic above the list
Cont_After_Adjust24:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: args
 mov rax, PVAR(1)
push rax
; create a varParam: f
 mov rax, PVAR(0)
push rax

Noa25:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create BoxGet :
; create a bound param: map-many
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*0]
mov rax, qword[rax]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
leave
ret
;end of the body (closure)
Lcont24:

leave
ret
;end of the body (closure)
Lcont23:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic

leave
ret
;end of the body (closure)
Lcont4:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
leave
    ret
;end of the body (closure)
    Lcont2:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
mov qword[fvar_tbl+WORD_SIZE*32], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;create Def: 
;create Set for varFree fold-left:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a free param: cdr
 mov rax, qword [fvar_tbl+ WORD_SIZE*28]
push rax
; create a free param: car
 mov rax, qword [fvar_tbl+ WORD_SIZE*27]
push rax
; create a free param: null?
 mov rax, qword [fvar_tbl+ WORD_SIZE*4]
push rax

Noa26:
mov r10, 3;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple first layer:
    MAKE_CLOSURE(rax,  SOB_NIL_ADDRESS, Lcode27)
    ;jump beyond the Body
    jmp Lcont27
    Lcode27:
    push rbp
    mov rbp, rsp
    ;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a const
mov rax, const_tbl+23
push rax

Noa28:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*2
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking29:
mov rcx, 0 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env29 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop29:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop29
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env29:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check129:
cmp rcx, 0
je Continue_Allocate_Closure_Object29
check229:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop29:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop29
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object29:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode29)
;jump beyond the Body
jmp Lcont29
Lcode29:
push rbp
mov rbp, rsp
;create a seq:
;create Set for varParam fl-loop:
;create a Box:
MALLOC r8, WORD_SIZE
; create a varParam: fl-loop
 mov rax, PVAR(0)

mov qword [r8], rax
mov rax, r8
mov PVAR(0), rax
 mov rax, SOB_VOID_ADDRESS
;create BoxSet :
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking30:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env30 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop30:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop30
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env30:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check130:
cmp rcx, 0
je Continue_Allocate_Closure_Object30
check230:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop30:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop30
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object30:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode30)
;jump beyond the Body
jmp Lcont30
Lcode30:
push rbp
mov rbp, rsp
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: lst
 mov rax, PVAR(2)
push rax

Noa36:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: null?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse31
; create a varParam: obj
 mov rax, PVAR(1)
jmp lexit31
lelse31:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: lst
 mov rax, PVAR(2)
push rax

Noa35:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: cdr
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*2]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: lst
 mov rax, PVAR(2)
push rax

Noa34:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: car
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*1]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
; create a varParam: obj
 mov rax, PVAR(1)
push rax

Noa33:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a varParam: proc
 mov rax, PVAR(0)

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
; create a varParam: proc
 mov rax, PVAR(0)
push rax

Noa32:
mov r10, 3;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create BoxGet :
; create a bound param: fl-loop
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]
mov rax, qword[rax]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
lexit31:

leave
ret
;end of the body (closure)
Lcont30:
push rax
; create a varParam: fl-loop
 mov rax, PVAR(0)
pop qword[rax]
mov rax, SOB_VOID_ADDRESS
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic

Noa37:
mov r10, 0;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking38:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env38 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop38:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop38
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env38:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check138:
cmp rcx, 0
je Continue_Allocate_Closure_Object38
check238:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop38:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop38
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object38:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode38)
;jump beyond the Body
jmp Lcont38
Lcode38:
push rbp
mov rbp, rsp
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*4
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking39:
mov rcx, 2 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env39 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop39:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop39
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env39:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check139:
cmp rcx, 0
je Continue_Allocate_Closure_Object39
check239:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop39:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop39
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object39:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode39)
;jump beyond the Body
jmp Lcont39
Lcode39:
push rbp
mov rbp, rsp
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: l
 mov rax, PVAR(2)
push rax
; create a varParam: o
 mov rax, PVAR(1)
push rax
; create a varParam: p
 mov rax, PVAR(0)
push rax

Noa40:
mov r10, 3;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create BoxGet :
; create a bound param: fl-loop
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*0]
mov rax, qword[rax]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic

leave
ret
;end of the body (closure)
Lcont39:

leave
ret
;end of the body (closure)
Lcont38:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic

leave
ret
;end of the body (closure)
Lcont29:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
leave
    ret
;end of the body (closure)
    Lcont27:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
mov qword[fvar_tbl+WORD_SIZE*33], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;create Def: 
;create Set for varFree fold-right:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a free param: cdr
 mov rax, qword [fvar_tbl+ WORD_SIZE*28]
push rax
; create a free param: car
 mov rax, qword [fvar_tbl+ WORD_SIZE*27]
push rax
; create a free param: null?
 mov rax, qword [fvar_tbl+ WORD_SIZE*4]
push rax

Noa41:
mov r10, 3;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple first layer:
    MAKE_CLOSURE(rax,  SOB_NIL_ADDRESS, Lcode42)
    ;jump beyond the Body
    jmp Lcont42
    Lcode42:
    push rbp
    mov rbp, rsp
    ;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a const
mov rax, const_tbl+23
push rax

Noa43:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*2
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking44:
mov rcx, 0 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env44 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop44:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop44
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env44:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check144:
cmp rcx, 0
je Continue_Allocate_Closure_Object44
check244:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop44:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop44
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object44:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode44)
;jump beyond the Body
jmp Lcont44
Lcode44:
push rbp
mov rbp, rsp
;create a seq:
;create Set for varParam fr-loop:
;create a Box:
MALLOC r8, WORD_SIZE
; create a varParam: fr-loop
 mov rax, PVAR(0)

mov qword [r8], rax
mov rax, r8
mov PVAR(0), rax
 mov rax, SOB_VOID_ADDRESS
;create BoxSet :
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking45:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env45 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop45:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop45
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env45:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check145:
cmp rcx, 0
je Continue_Allocate_Closure_Object45
check245:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop45:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop45
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object45:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode45)
;jump beyond the Body
jmp Lcont45
Lcode45:
push rbp
mov rbp, rsp
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: lst
 mov rax, PVAR(2)
push rax

Noa51:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: null?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse46
; create a varParam: obj
 mov rax, PVAR(1)
jmp lexit46
lelse46:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: lst
 mov rax, PVAR(2)
push rax

Noa50:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: cdr
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*2]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
; create a varParam: obj
 mov rax, PVAR(1)
push rax
; create a varParam: proc
 mov rax, PVAR(0)
push rax

Noa49:
mov r10, 3;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create BoxGet :
; create a bound param: fr-loop
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]
mov rax, qword[rax]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: lst
 mov rax, PVAR(2)
push rax

Noa48:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: car
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*1]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa47:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a varParam: proc
 mov rax, PVAR(0)

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
lexit46:

leave
ret
;end of the body (closure)
Lcont45:
push rax
; create a varParam: fr-loop
 mov rax, PVAR(0)
pop qword[rax]
mov rax, SOB_VOID_ADDRESS
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic

Noa52:
mov r10, 0;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking53:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env53 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop53:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop53
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env53:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check153:
cmp rcx, 0
je Continue_Allocate_Closure_Object53
check253:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop53:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop53
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object53:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode53)
;jump beyond the Body
jmp Lcont53
Lcode53:
push rbp
mov rbp, rsp
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*4
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking54:
mov rcx, 2 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env54 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop54:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop54
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env54:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check154:
cmp rcx, 0
je Continue_Allocate_Closure_Object54
check254:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop54:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop54
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object54:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode54)
;jump beyond the Body
jmp Lcont54
Lcode54:
push rbp
mov rbp, rsp
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: l
 mov rax, PVAR(2)
push rax
; create a varParam: o
 mov rax, PVAR(1)
push rax
; create a varParam: p
 mov rax, PVAR(0)
push rax

Noa55:
mov r10, 3;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create BoxGet :
; create a bound param: fr-loop
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*0]
mov rax, qword[rax]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic

leave
ret
;end of the body (closure)
Lcont54:

leave
ret
;end of the body (closure)
Lcont53:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic

leave
ret
;end of the body (closure)
Lcont44:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
leave
    ret
;end of the body (closure)
    Lcont42:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
mov qword[fvar_tbl+WORD_SIZE*34], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;create Def: 
;create Set for varFree reverse:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a free param: cons
 mov rax, qword [fvar_tbl+ WORD_SIZE*29]
push rax
; create a free param: cdr
 mov rax, qword [fvar_tbl+ WORD_SIZE*28]
push rax
; create a free param: car
 mov rax, qword [fvar_tbl+ WORD_SIZE*27]
push rax
; create a free param: null?
 mov rax, qword [fvar_tbl+ WORD_SIZE*4]
push rax

Noa56:
mov r10, 4;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple first layer:
    MAKE_CLOSURE(rax,  SOB_NIL_ADDRESS, Lcode57)
    ;jump beyond the Body
    jmp Lcont57
    Lcode57:
    push rbp
    mov rbp, rsp
    ;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a const
mov rax, const_tbl+23
push rax

Noa58:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*2
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking59:
mov rcx, 0 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env59 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop59:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop59
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env59:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check159:
cmp rcx, 0
je Continue_Allocate_Closure_Object59
check259:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop59:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop59
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object59:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode59)
;jump beyond the Body
jmp Lcont59
Lcode59:
push rbp
mov rbp, rsp
;create a seq:
;create Set for varParam reverse-loop:
;create a Box:
MALLOC r8, WORD_SIZE
; create a varParam: reverse-loop
 mov rax, PVAR(0)

mov qword [r8], rax
mov rax, r8
mov PVAR(0), rax
 mov rax, SOB_VOID_ADDRESS
;create BoxSet :
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking60:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env60 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop60:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop60
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env60:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check160:
cmp rcx, 0
je Continue_Allocate_Closure_Object60
check260:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop60:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop60
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object60:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode60)
;jump beyond the Body
jmp Lcont60
Lcode60:
push rbp
mov rbp, rsp
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: lst
 mov rax, PVAR(0)
push rax

Noa66:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: null?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse61
; create a varParam: acc
 mov rax, PVAR(1)
jmp lexit61
lelse61:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: acc
 mov rax, PVAR(1)
push rax
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: lst
 mov rax, PVAR(0)
push rax

Noa65:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: car
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*1]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa64:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: cons
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*3]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: lst
 mov rax, PVAR(0)
push rax

Noa63:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: cdr
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*2]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa62:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create BoxGet :
; create a bound param: reverse-loop
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]
mov rax, qword[rax]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
lexit61:

leave
ret
;end of the body (closure)
Lcont60:
push rax
; create a varParam: reverse-loop
 mov rax, PVAR(0)
pop qword[rax]
mov rax, SOB_VOID_ADDRESS
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic

Noa67:
mov r10, 0;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking68:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env68 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop68:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop68
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env68:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check168:
cmp rcx, 0
je Continue_Allocate_Closure_Object68
check268:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop68:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop68
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object68:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode68)
;jump beyond the Body
jmp Lcont68
Lcode68:
push rbp
mov rbp, rsp
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*4
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking69:
mov rcx, 2 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env69 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop69:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop69
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env69:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check169:
cmp rcx, 0
je Continue_Allocate_Closure_Object69
check269:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop69:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop69
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object69:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode69)
;jump beyond the Body
jmp Lcont69
Lcode69:
push rbp
mov rbp, rsp
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a const
mov rax, const_tbl+1
push rax
; create a varParam: lst
 mov rax, PVAR(0)
push rax

Noa70:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create BoxGet :
; create a bound param: reverse-loop
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*0]
mov rax, qword[rax]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic

leave
ret
;end of the body (closure)
Lcont69:

leave
ret
;end of the body (closure)
Lcont68:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic

leave
ret
;end of the body (closure)
Lcont59:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
leave
    ret
;end of the body (closure)
    Lcont57:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
mov qword[fvar_tbl+WORD_SIZE*35], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;create Def: 
;create Set for varFree cons*:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a free param: reverse
 mov rax, qword [fvar_tbl+ WORD_SIZE*35]
push rax
; create a free param: fold-right
 mov rax, qword [fvar_tbl+ WORD_SIZE*34]
push rax
; create a free param: cons
 mov rax, qword [fvar_tbl+ WORD_SIZE*29]
push rax
; create a free param: cdr
 mov rax, qword [fvar_tbl+ WORD_SIZE*28]
push rax
; create a free param: car
 mov rax, qword [fvar_tbl+ WORD_SIZE*27]
push rax
; create a free param: null?
 mov rax, qword [fvar_tbl+ WORD_SIZE*4]
push rax

Noa71:
mov r10, 6;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple first layer:
    MAKE_CLOSURE(rax,  SOB_NIL_ADDRESS, Lcode72)
    ;jump beyond the Body
    jmp Lcont72
    Lcode72:
    push rbp
    mov rbp, rsp
    ;create LambdaOpt multiple layers:
;code for_ext env
MALLOC rdx, WORD_SIZE*2
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking73:
mov rcx, 0 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env73 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop73:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop73
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env73:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check173:
cmp rcx, 0
je Continue_Allocate_Closure_Object73
check273:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop73:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop73
Continue_Allocate_Closure_Object73:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode73)
;jump beyond the Body
jmp Lcont73
Lcode73:
push rbp
mov rbp, rsp
mov rbx, qword[rbp+ 8*3] ; rbp=n (num of initial params)
mov r8, 0 ; r8= num of must params
cmp rbx, r8 ;comparing the numbers of params with the number of the must params 
je Cont_After_Adjust73
;now code to adjust the params 
mov rcx, rbx ; ecx in now num of params 
sub rcx, r8; ecx now is num of iterations=> (num of params)- (num of must params)
add rbx, 3  ; 
shl rbx,  3 ; mutiply (n+3)*8-> distance from the An to rbx
mov r9, [rbp+rbx] ;r9=A0
mov r10, [rbp+rbx+WORD_SIZE] ;r10 holds the magic
MAKE_PAIR(r11, r9, r10) ; r11 now point to the pair(An, SOB_NIl_ADDRESS
sub rcx, 1 ; one less iteraition
cmp rcx, 0
je Cont_after_r11_list73
sub rbx, WORD_SIZE
Loop_Make_List73:
;Looop invariant r11 always points to the last Pair
mov r8, r11 ; now r8 point to the last Pair
mov r9, [rbp+rbx]; r9 point to A(i-1)
MAKE_PAIR(r11, r9,r8)
sub rbx, WORD_SIZE
loop Loop_Make_List73
Cont_after_r11_list73:
;now r11 point to the Pairs. to the list
mov qword [rbp + (4+0)*8], r11 ;the pointer to the list is right above the last must params
mov qword [rbp + (4+1)*8], SOB_NIL_ADDRESS ; magic above the list
Cont_After_Adjust73:
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: args
 mov rax, PVAR(0)
push rax

Noa81:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: null?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse74
; create a varParam: args
 mov rax, PVAR(0)
jmp lexit74
lelse74:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: args
 mov rax, PVAR(0)
push rax

Noa80:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: reverse
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*5]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa79:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: cdr
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*2]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa78:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: reverse
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*5]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: args
 mov rax, PVAR(0)
push rax

Noa77:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: reverse
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*5]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa76:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: car
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*1]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
; create a bound param: cons
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*3]
push rax

Noa75:
mov r10, 3;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: fold-right
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*4]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
lexit74:
leave
ret
;end of the body (closure)
Lcont73:
leave
    ret
;end of the body (closure)
    Lcont72:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
mov qword[fvar_tbl+WORD_SIZE*36], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;create Def: 
;create Set for varFree append:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a free param: cons
 mov rax, qword [fvar_tbl+ WORD_SIZE*29]
push rax
; create a free param: fold-right
 mov rax, qword [fvar_tbl+ WORD_SIZE*34]
push rax
; create a free param: null?
 mov rax, qword [fvar_tbl+ WORD_SIZE*4]
push rax

Noa82:
mov r10, 3;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple first layer:
    MAKE_CLOSURE(rax,  SOB_NIL_ADDRESS, Lcode83)
    ;jump beyond the Body
    jmp Lcont83
    Lcode83:
    push rbp
    mov rbp, rsp
    ;create LambdaOpt multiple layers:
;code for_ext env
MALLOC rdx, WORD_SIZE*2
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking84:
mov rcx, 0 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env84 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop84:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop84
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env84:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check184:
cmp rcx, 0
je Continue_Allocate_Closure_Object84
check284:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop84:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop84
Continue_Allocate_Closure_Object84:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode84)
;jump beyond the Body
jmp Lcont84
Lcode84:
push rbp
mov rbp, rsp
mov rbx, qword[rbp+ 8*3] ; rbp=n (num of initial params)
mov r8, 0 ; r8= num of must params
cmp rbx, r8 ;comparing the numbers of params with the number of the must params 
je Cont_After_Adjust84
;now code to adjust the params 
mov rcx, rbx ; ecx in now num of params 
sub rcx, r8; ecx now is num of iterations=> (num of params)- (num of must params)
add rbx, 3  ; 
shl rbx,  3 ; mutiply (n+3)*8-> distance from the An to rbx
mov r9, [rbp+rbx] ;r9=A0
mov r10, [rbp+rbx+WORD_SIZE] ;r10 holds the magic
MAKE_PAIR(r11, r9, r10) ; r11 now point to the pair(An, SOB_NIl_ADDRESS
sub rcx, 1 ; one less iteraition
cmp rcx, 0
je Cont_after_r11_list84
sub rbx, WORD_SIZE
Loop_Make_List84:
;Looop invariant r11 always points to the last Pair
mov r8, r11 ; now r8 point to the last Pair
mov r9, [rbp+rbx]; r9 point to A(i-1)
MAKE_PAIR(r11, r9,r8)
sub rbx, WORD_SIZE
loop Loop_Make_List84
Cont_after_r11_list84:
;now r11 point to the Pairs. to the list
mov qword [rbp + (4+0)*8], r11 ;the pointer to the list is right above the last must params
mov qword [rbp + (4+1)*8], SOB_NIL_ADDRESS ; magic above the list
Cont_After_Adjust84:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: args
 mov rax, PVAR(0)
push rax
; create a const
mov rax, const_tbl+1
push rax
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking86:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env86 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop86:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop86
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env86:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check186:
cmp rcx, 0
je Continue_Allocate_Closure_Object86
check286:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop86:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop86
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object86:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode86)
;jump beyond the Body
jmp Lcont86
Lcode86:
push rbp
mov rbp, rsp
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: a
 mov rax, PVAR(1)
push rax

Noa89:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: null?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse87
; create a varParam: e
 mov rax, PVAR(0)
jmp lexit87
lelse87:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: e
 mov rax, PVAR(0)
push rax
; create a varParam: a
 mov rax, PVAR(1)
push rax
; create a bound param: cons
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*2]
push rax

Noa88:
mov r10, 3;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: fold-right
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*1]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
lexit87:

leave
ret
;end of the body (closure)
Lcont86:
push rax

Noa85:
mov r10, 3;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: fold-right
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*1]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
leave
ret
;end of the body (closure)
Lcont84:
leave
    ret
;end of the body (closure)
    Lcont83:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
mov qword[fvar_tbl+WORD_SIZE*37], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;create Def: 
;create Set for varFree list:
;create LambdaOpt first layer:
MAKE_CLOSURE(rax,  SOB_NIL_ADDRESS, Lcode90)
;jump beyond the Body
jmp Lcont90
Lcode90:
push rbp
mov rbp, rsp
mov rbx, qword[rbp+ 8*3] ; rbp=n (num of initial params)
mov r8, 0 ; r8= num of must params
cmp rbx, r8 ;comparing the numbers of params with the number of the must params 
je Cont_After_Adjust90
;now code to adjust the params 
mov rcx, rbx ; ecx in now num of params 
sub rcx, r8; ecx now is num of iterations=> (num of params)- (num of must params)
add rbx, 3  ; 
shl rbx,  3 ; mutiply (n+3)*8-> distance from the An to rbx
mov r9, [rbp+rbx] ;r9=A0
mov r10, [rbp+rbx+WORD_SIZE] ;r10 holds the magic
MAKE_PAIR(r11, r9, r10) ; r11 now point to the pair(An, SOB_NIl_ADDRESS
sub rcx, 1 ; one less iteraition
cmp rcx, 0
je Continue_List_ready90
sub rbx, WORD_SIZE
Loop_Make_List90:
;Looop invariant r11 always points to the last Pair
mov r8, r11 ; now r8 point to the last Pair
mov r9, [rbp+rbx]; r9 point to A(i-1)
MAKE_PAIR(r11, r9,r8)
sub rbx, WORD_SIZE
loop Loop_Make_List90
Continue_List_ready90:
;now r11 point to the Pairs. to the list
mov qword [rbp + (4+0)*8], r11 ;the pointer to the list is right above the last must params
mov qword [rbp + (4+1)*8], SOB_NIL_ADDRESS ; magic above the list
Cont_After_Adjust90:
; create a varParam: x
 mov rax, PVAR(0)
leave
ret
;end of the body (closure)
Lcont90:
mov qword[fvar_tbl+WORD_SIZE*38], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;create Def: 
;create Set for varFree list?:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a free param: cdr
 mov rax, qword [fvar_tbl+ WORD_SIZE*28]
push rax
; create a free param: pair?
 mov rax, qword [fvar_tbl+ WORD_SIZE*3]
push rax
; create a free param: null?
 mov rax, qword [fvar_tbl+ WORD_SIZE*4]
push rax

Noa91:
mov r10, 3;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple first layer:
    MAKE_CLOSURE(rax,  SOB_NIL_ADDRESS, Lcode92)
    ;jump beyond the Body
    jmp Lcont92
    Lcode92:
    push rbp
    mov rbp, rsp
    ;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a const
mov rax, const_tbl+23
push rax

Noa93:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*2
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking94:
mov rcx, 0 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env94 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop94:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop94
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env94:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check194:
cmp rcx, 0
je Continue_Allocate_Closure_Object94
check294:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop94:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop94
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object94:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode94)
;jump beyond the Body
jmp Lcont94
Lcode94:
push rbp
mov rbp, rsp
;create a seq:
;create Set for varParam list?-loop:
;create a Box:
MALLOC r8, WORD_SIZE
; create a varParam: list?-loop
 mov rax, PVAR(0)

mov qword [r8], rax
mov rax, r8
mov PVAR(0), rax
 mov rax, SOB_VOID_ADDRESS
;create BoxSet :
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking95:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env95 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop95:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop95
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env95:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check195:
cmp rcx, 0
je Continue_Allocate_Closure_Object95
check295:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop95:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop95
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object95:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode95)
;jump beyond the Body
jmp Lcont95
Lcode95:
push rbp
mov rbp, rsp
;create Or:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa101:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: null?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
jne lexit96
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa100:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: pair?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*1]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse97
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa99:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: cdr
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*2]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa98:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create BoxGet :
; create a bound param: list?-loop
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]
mov rax, qword[rax]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
jmp lexit97
lelse97:
; create a const
mov rax, const_tbl+2
lexit97:
lexit96:

leave
ret
;end of the body (closure)
Lcont95:
push rax
; create a varParam: list?-loop
 mov rax, PVAR(0)
pop qword[rax]
mov rax, SOB_VOID_ADDRESS
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic

Noa102:
mov r10, 0;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking103:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env103 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop103:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop103
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env103:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1103:
cmp rcx, 0
je Continue_Allocate_Closure_Object103
check2103:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop103:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop103
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object103:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode103)
;jump beyond the Body
jmp Lcont103
Lcode103:
push rbp
mov rbp, rsp
;create BoxGet :
; create a bound param: list?-loop
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]
mov rax, qword[rax]

leave
ret
;end of the body (closure)
Lcont103:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic

leave
ret
;end of the body (closure)
Lcont94:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
leave
    ret
;end of the body (closure)
    Lcont92:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
mov qword[fvar_tbl+WORD_SIZE*39], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;create Def: 
;create Set for varFree not:
;create LambdaSimple first layer:
    MAKE_CLOSURE(rax,  SOB_NIL_ADDRESS, Lcode104)
    ;jump beyond the Body
    jmp Lcont104
    Lcode104:
    push rbp
    mov rbp, rsp
    ;create If:
; create a varParam: x
 mov rax, PVAR(0)
cmp rax, SOB_FALSE_ADDRESS
je lelse105
; create a const
mov rax, const_tbl+2
jmp lexit105
lelse105:
; create a const
mov rax, const_tbl+4
lexit105:
leave
    ret
;end of the body (closure)
    Lcont104:
mov qword[fvar_tbl+WORD_SIZE*40], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a free param: null?
 mov rax, qword [fvar_tbl+ WORD_SIZE*4]
push rax
; create a free param: cdr
 mov rax, qword [fvar_tbl+ WORD_SIZE*28]
push rax
; create a free param: car
 mov rax, qword [fvar_tbl+ WORD_SIZE*27]
push rax
; create a free param: <
 mov rax, qword [fvar_tbl+ WORD_SIZE*22]
push rax
; create a free param: =
 mov rax, qword [fvar_tbl+ WORD_SIZE*21]
push rax
; create a free param: /
 mov rax, qword [fvar_tbl+ WORD_SIZE*20]
push rax
; create a free param: *
 mov rax, qword [fvar_tbl+ WORD_SIZE*19]
push rax
; create a free param: +
 mov rax, qword [fvar_tbl+ WORD_SIZE*18]
push rax
; create a free param: map
 mov rax, qword [fvar_tbl+ WORD_SIZE*32]
push rax
; create a free param: fold-left
 mov rax, qword [fvar_tbl+ WORD_SIZE*33]
push rax
; create a free param: exact->inexact
 mov rax, qword [fvar_tbl+ WORD_SIZE*16]
push rax
; create a free param: rational?
 mov rax, qword [fvar_tbl+ WORD_SIZE*2]
push rax
; create a free param: flonum?
 mov rax, qword [fvar_tbl+ WORD_SIZE*1]
push rax

Noa106:
mov r10, 13;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple first layer:
    MAKE_CLOSURE(rax,  SOB_NIL_ADDRESS, Lcode107)
    ;jump beyond the Body
    jmp Lcont107
    Lcode107:
    push rbp
    mov rbp, rsp
    ;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*2
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking146:
mov rcx, 0 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env146 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop146:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop146
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env146:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1146:
cmp rcx, 0
je Continue_Allocate_Closure_Object146
check2146:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop146:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop146
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object146:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode146)
;jump beyond the Body
jmp Lcont146
Lcode146:
push rbp
mov rbp, rsp
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking147:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env147 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop147:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop147
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env147:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1147:
cmp rcx, 0
je Continue_Allocate_Closure_Object147
check2147:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop147:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop147
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object147:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode147)
;jump beyond the Body
jmp Lcont147
Lcode147:
push rbp
mov rbp, rsp
;create If:
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa160:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: flonum?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse158
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: y
 mov rax, PVAR(1)
push rax

Noa159:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: rational?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*1]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
jmp lexit158
lelse158:
; create a const
mov rax, const_tbl+2
lexit158:
cmp rax, SOB_FALSE_ADDRESS
je lelse148
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: y
 mov rax, PVAR(1)
push rax

Noa157:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: exact->inexact
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*2]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa156:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: op
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
jmp lexit148
lelse148:
;create If:
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa155:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: rational?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*1]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse153
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: y
 mov rax, PVAR(1)
push rax

Noa154:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: flonum?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
jmp lexit153
lelse153:
; create a const
mov rax, const_tbl+2
lexit153:
cmp rax, SOB_FALSE_ADDRESS
je lelse149
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: y
 mov rax, PVAR(1)
push rax
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa152:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: exact->inexact
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*2]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa151:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: op
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
jmp lexit149
lelse149:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: y
 mov rax, PVAR(1)
push rax
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa150:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: op
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
lexit149:
lexit148:

leave
ret
;end of the body (closure)
Lcont147:

leave
ret
;end of the body (closure)
Lcont146:
push rax

Noa108:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*2
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking109:
mov rcx, 0 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env109 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop109:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop109
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env109:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1109:
cmp rcx, 0
je Continue_Allocate_Closure_Object109
check2109:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop109:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop109
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object109:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode109)
;jump beyond the Body
jmp Lcont109
Lcode109:
push rbp
mov rbp, rsp
;create a seq:
;create Set for varFree +:
;create LambdaOpt multiple layers:
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking110:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env110 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop110:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop110
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env110:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1110:
cmp rcx, 0
je Continue_Allocate_Closure_Object110
check2110:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop110:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop110
Continue_Allocate_Closure_Object110:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode110)
;jump beyond the Body
jmp Lcont110
Lcode110:
push rbp
mov rbp, rsp
mov rbx, qword[rbp+ 8*3] ; rbp=n (num of initial params)
mov r8, 0 ; r8= num of must params
cmp rbx, r8 ;comparing the numbers of params with the number of the must params 
je Cont_After_Adjust110
;now code to adjust the params 
mov rcx, rbx ; ecx in now num of params 
sub rcx, r8; ecx now is num of iterations=> (num of params)- (num of must params)
add rbx, 3  ; 
shl rbx,  3 ; mutiply (n+3)*8-> distance from the An to rbx
mov r9, [rbp+rbx] ;r9=A0
mov r10, [rbp+rbx+WORD_SIZE] ;r10 holds the magic
MAKE_PAIR(r11, r9, r10) ; r11 now point to the pair(An, SOB_NIl_ADDRESS
sub rcx, 1 ; one less iteraition
cmp rcx, 0
je Cont_after_r11_list110
sub rbx, WORD_SIZE
Loop_Make_List110:
;Looop invariant r11 always points to the last Pair
mov r8, r11 ; now r8 point to the last Pair
mov r9, [rbp+rbx]; r9 point to A(i-1)
MAKE_PAIR(r11, r9,r8)
sub rbx, WORD_SIZE
loop Loop_Make_List110
Cont_after_r11_list110:
;now r11 point to the Pairs. to the list
mov qword [rbp + (4+0)*8], r11 ;the pointer to the list is right above the last must params
mov qword [rbp + (4+1)*8], SOB_NIL_ADDRESS ; magic above the list
Cont_After_Adjust110:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax
; create a const
mov rax, const_tbl+32
push rax
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a bound param: _+
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*5]
push rax

Noa112:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: ^numeric-op-dispatcher
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa111:
mov r10, 3;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: fold-left
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*3]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
leave
ret
;end of the body (closure)
Lcont110:
mov qword[fvar_tbl+WORD_SIZE*18], rax
mov rax, SOB_VOID_ADDRESS
;create Set for varFree *:
;create LambdaOpt multiple layers:
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking113:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env113 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop113:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop113
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env113:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1113:
cmp rcx, 0
je Continue_Allocate_Closure_Object113
check2113:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop113:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop113
Continue_Allocate_Closure_Object113:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode113)
;jump beyond the Body
jmp Lcont113
Lcode113:
push rbp
mov rbp, rsp
mov rbx, qword[rbp+ 8*3] ; rbp=n (num of initial params)
mov r8, 0 ; r8= num of must params
cmp rbx, r8 ;comparing the numbers of params with the number of the must params 
je Cont_After_Adjust113
;now code to adjust the params 
mov rcx, rbx ; ecx in now num of params 
sub rcx, r8; ecx now is num of iterations=> (num of params)- (num of must params)
add rbx, 3  ; 
shl rbx,  3 ; mutiply (n+3)*8-> distance from the An to rbx
mov r9, [rbp+rbx] ;r9=A0
mov r10, [rbp+rbx+WORD_SIZE] ;r10 holds the magic
MAKE_PAIR(r11, r9, r10) ; r11 now point to the pair(An, SOB_NIl_ADDRESS
sub rcx, 1 ; one less iteraition
cmp rcx, 0
je Cont_after_r11_list113
sub rbx, WORD_SIZE
Loop_Make_List113:
;Looop invariant r11 always points to the last Pair
mov r8, r11 ; now r8 point to the last Pair
mov r9, [rbp+rbx]; r9 point to A(i-1)
MAKE_PAIR(r11, r9,r8)
sub rbx, WORD_SIZE
loop Loop_Make_List113
Cont_after_r11_list113:
;now r11 point to the Pairs. to the list
mov qword [rbp + (4+0)*8], r11 ;the pointer to the list is right above the last must params
mov qword [rbp + (4+1)*8], SOB_NIL_ADDRESS ; magic above the list
Cont_After_Adjust113:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax
; create a const
mov rax, const_tbl+49
push rax
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a bound param: _*
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*6]
push rax

Noa115:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: ^numeric-op-dispatcher
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa114:
mov r10, 3;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: fold-left
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*3]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
leave
ret
;end of the body (closure)
Lcont113:
mov qword[fvar_tbl+WORD_SIZE*19], rax
mov rax, SOB_VOID_ADDRESS
;create Set for varFree /:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a bound param: _/
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*7]
push rax

Noa123:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a varParam: ^numeric-op-dispatcher
 mov rax, PVAR(0)

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa116:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking117:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env117 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop117:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop117
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env117:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1117:
cmp rcx, 0
je Continue_Allocate_Closure_Object117
check2117:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop117:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop117
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object117:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode117)
;jump beyond the Body
jmp Lcont117
Lcode117:
push rbp
mov rbp, rsp
;create LambdaOpt multiple layers:
;code for_ext env
MALLOC rdx, WORD_SIZE*4
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking118:
mov rcx, 2 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env118 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop118:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop118
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env118:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1118:
cmp rcx, 0
je Continue_Allocate_Closure_Object118
check2118:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop118:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop118
Continue_Allocate_Closure_Object118:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode118)
;jump beyond the Body
jmp Lcont118
Lcode118:
push rbp
mov rbp, rsp
mov rbx, qword[rbp+ 8*3] ; rbp=n (num of initial params)
mov r8, 1 ; r8= num of must params
cmp rbx, r8 ;comparing the numbers of params with the number of the must params 
je Cont_After_Adjust118
;now code to adjust the params 
mov rcx, rbx ; ecx in now num of params 
sub rcx, r8; ecx now is num of iterations=> (num of params)- (num of must params)
add rbx, 3  ; 
shl rbx,  3 ; mutiply (n+3)*8-> distance from the An to rbx
mov r9, [rbp+rbx] ;r9=A0
mov r10, [rbp+rbx+WORD_SIZE] ;r10 holds the magic
MAKE_PAIR(r11, r9, r10) ; r11 now point to the pair(An, SOB_NIl_ADDRESS
sub rcx, 1 ; one less iteraition
cmp rcx, 0
je Cont_after_r11_list118
sub rbx, WORD_SIZE
Loop_Make_List118:
;Looop invariant r11 always points to the last Pair
mov r8, r11 ; now r8 point to the last Pair
mov r9, [rbp+rbx]; r9 point to A(i-1)
MAKE_PAIR(r11, r9,r8)
sub rbx, WORD_SIZE
loop Loop_Make_List118
Cont_after_r11_list118:
;now r11 point to the Pairs. to the list
mov qword [rbp + (4+1)*8], r11 ;the pointer to the list is right above the last must params
mov qword [rbp + (4+2)*8], SOB_NIL_ADDRESS ; magic above the list
Cont_After_Adjust118:
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: y
 mov rax, PVAR(1)
push rax

Noa122:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: null?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*2]
 mov rax, qword[rax+ 8*12]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse119
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax
; create a const
mov rax, const_tbl+49
push rax

Noa121:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: /
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
jmp lexit119
lelse119:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: y
 mov rax, PVAR(1)
push rax
; create a varParam: x
 mov rax, PVAR(0)
push rax
; create a bound param: /
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]
push rax

Noa120:
mov r10, 3;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: fold-left
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*2]
 mov rax, qword[rax+ 8*3]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
lexit119:
leave
ret
;end of the body (closure)
Lcont118:

leave
ret
;end of the body (closure)
Lcont117:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
mov qword[fvar_tbl+WORD_SIZE*20], rax
mov rax, SOB_VOID_ADDRESS
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking130:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env130 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop130:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop130
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env130:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1130:
cmp rcx, 0
je Continue_Allocate_Closure_Object130
check2130:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop130:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop130
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object130:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode130)
;jump beyond the Body
jmp Lcont130
Lcode130:
push rbp
mov rbp, rsp
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a const
mov rax, const_tbl+23
push rax

Noa131:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*4
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking132:
mov rcx, 2 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env132 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop132:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop132
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env132:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1132:
cmp rcx, 0
je Continue_Allocate_Closure_Object132
check2132:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop132:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop132
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object132:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode132)
;jump beyond the Body
jmp Lcont132
Lcode132:
push rbp
mov rbp, rsp
;create a seq:
;create Set for varParam comparator:
;create a Box:
MALLOC r8, WORD_SIZE
; create a varParam: comparator
 mov rax, PVAR(0)

mov qword [r8], rax
mov rax, r8
mov PVAR(0), rax
 mov rax, SOB_VOID_ADDRESS
;create BoxSet :
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*5
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking133:
mov rcx, 3 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env133 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop133:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop133
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env133:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1133:
cmp rcx, 0
je Continue_Allocate_Closure_Object133
check2133:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop133:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop133
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object133:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode133)
;jump beyond the Body
jmp Lcont133
Lcode133:
push rbp
mov rbp, rsp
;create Or:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: ys
 mov rax, PVAR(1)
push rax

Noa141:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: null?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*3]
 mov rax, qword[rax+ 8*12]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
jne lexit134
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: ys
 mov rax, PVAR(1)
push rax

Noa140:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: car
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*3]
 mov rax, qword[rax+ 8*10]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa139:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: op
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse135
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: ys
 mov rax, PVAR(1)
push rax

Noa138:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: cdr
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*3]
 mov rax, qword[rax+ 8*11]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: ys
 mov rax, PVAR(1)
push rax

Noa137:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: car
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*3]
 mov rax, qword[rax+ 8*10]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa136:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create BoxGet :
; create a bound param: comparator
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]
mov rax, qword[rax]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
jmp lexit135
lelse135:
; create a const
mov rax, const_tbl+2
lexit135:
lexit134:

leave
ret
;end of the body (closure)
Lcont133:
push rax
; create a varParam: comparator
 mov rax, PVAR(0)
pop qword[rax]
mov rax, SOB_VOID_ADDRESS
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic

Noa142:
mov r10, 0;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*5
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking143:
mov rcx, 3 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env143 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop143:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop143
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env143:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1143:
cmp rcx, 0
je Continue_Allocate_Closure_Object143
check2143:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop143:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop143
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object143:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode143)
;jump beyond the Body
jmp Lcont143
Lcode143:
push rbp
mov rbp, rsp
;create LambdaOpt multiple layers:
;code for_ext env
MALLOC rdx, WORD_SIZE*6
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking144:
mov rcx, 4 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env144 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop144:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop144
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env144:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1144:
cmp rcx, 0
je Continue_Allocate_Closure_Object144
check2144:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop144:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop144
Continue_Allocate_Closure_Object144:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode144)
;jump beyond the Body
jmp Lcont144
Lcode144:
push rbp
mov rbp, rsp
mov rbx, qword[rbp+ 8*3] ; rbp=n (num of initial params)
mov r8, 1 ; r8= num of must params
cmp rbx, r8 ;comparing the numbers of params with the number of the must params 
je Cont_After_Adjust144
;now code to adjust the params 
mov rcx, rbx ; ecx in now num of params 
sub rcx, r8; ecx now is num of iterations=> (num of params)- (num of must params)
add rbx, 3  ; 
shl rbx,  3 ; mutiply (n+3)*8-> distance from the An to rbx
mov r9, [rbp+rbx] ;r9=A0
mov r10, [rbp+rbx+WORD_SIZE] ;r10 holds the magic
MAKE_PAIR(r11, r9, r10) ; r11 now point to the pair(An, SOB_NIl_ADDRESS
sub rcx, 1 ; one less iteraition
cmp rcx, 0
je Cont_after_r11_list144
sub rbx, WORD_SIZE
Loop_Make_List144:
;Looop invariant r11 always points to the last Pair
mov r8, r11 ; now r8 point to the last Pair
mov r9, [rbp+rbx]; r9 point to A(i-1)
MAKE_PAIR(r11, r9,r8)
sub rbx, WORD_SIZE
loop Loop_Make_List144
Cont_after_r11_list144:
;now r11 point to the Pairs. to the list
mov qword [rbp + (4+1)*8], r11 ;the pointer to the list is right above the last must params
mov qword [rbp + (4+2)*8], SOB_NIL_ADDRESS ; magic above the list
Cont_After_Adjust144:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: y
 mov rax, PVAR(1)
push rax
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa145:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create BoxGet :
; create a bound param: comparator
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*0]
mov rax, qword[rax]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
leave
ret
;end of the body (closure)
Lcont144:

leave
ret
;end of the body (closure)
Lcont143:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic

leave
ret
;end of the body (closure)
Lcont132:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic

leave
ret
;end of the body (closure)
Lcont130:
push rax

Noa124:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking125:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env125 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop125:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop125
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env125:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1125:
cmp rcx, 0
je Continue_Allocate_Closure_Object125
check2125:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop125:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop125
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object125:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode125)
;jump beyond the Body
jmp Lcont125
Lcode125:
push rbp
mov rbp, rsp
;create a seq:
;create Set for varFree =:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a bound param: _=
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*8]
push rax

Noa127:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: ^numeric-op-dispatcher
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa126:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a varParam: ^comparator
 mov rax, PVAR(0)

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
mov qword[fvar_tbl+WORD_SIZE*21], rax
mov rax, SOB_VOID_ADDRESS
;create Set for varFree <:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a bound param: _<
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*9]
push rax

Noa129:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: ^numeric-op-dispatcher
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa128:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a varParam: ^comparator
 mov rax, PVAR(0)

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
mov qword[fvar_tbl+WORD_SIZE*22], rax
mov rax, SOB_VOID_ADDRESS

leave
ret
;end of the body (closure)
Lcont125:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic

leave
ret
;end of the body (closure)
Lcont109:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
leave
    ret
;end of the body (closure)
    Lcont107:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic

	call write_sob_if_not_void

;create Def: 
;create Set for varFree -:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a free param: null?
 mov rax, qword [fvar_tbl+ WORD_SIZE*4]
push rax
; create a free param: +
 mov rax, qword [fvar_tbl+ WORD_SIZE*18]
push rax
; create a free param: apply
 mov rax, qword [fvar_tbl+ WORD_SIZE*26]
push rax

Noa161:
mov r10, 3;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple first layer:
    MAKE_CLOSURE(rax,  SOB_NIL_ADDRESS, Lcode162)
    ;jump beyond the Body
    jmp Lcont162
    Lcode162:
    push rbp
    mov rbp, rsp
    ;create LambdaOpt multiple layers:
;code for_ext env
MALLOC rdx, WORD_SIZE*2
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking163:
mov rcx, 0 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env163 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop163:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop163
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env163:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1163:
cmp rcx, 0
je Continue_Allocate_Closure_Object163
check2163:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop163:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop163
Continue_Allocate_Closure_Object163:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode163)
;jump beyond the Body
jmp Lcont163
Lcode163:
push rbp
mov rbp, rsp
mov rbx, qword[rbp+ 8*3] ; rbp=n (num of initial params)
mov r8, 1 ; r8= num of must params
cmp rbx, r8 ;comparing the numbers of params with the number of the must params 
je Cont_After_Adjust163
;now code to adjust the params 
mov rcx, rbx ; ecx in now num of params 
sub rcx, r8; ecx now is num of iterations=> (num of params)- (num of must params)
add rbx, 3  ; 
shl rbx,  3 ; mutiply (n+3)*8-> distance from the An to rbx
mov r9, [rbp+rbx] ;r9=A0
mov r10, [rbp+rbx+WORD_SIZE] ;r10 holds the magic
MAKE_PAIR(r11, r9, r10) ; r11 now point to the pair(An, SOB_NIl_ADDRESS
sub rcx, 1 ; one less iteraition
cmp rcx, 0
je Cont_after_r11_list163
sub rbx, WORD_SIZE
Loop_Make_List163:
;Looop invariant r11 always points to the last Pair
mov r8, r11 ; now r8 point to the last Pair
mov r9, [rbp+rbx]; r9 point to A(i-1)
MAKE_PAIR(r11, r9,r8)
sub rbx, WORD_SIZE
loop Loop_Make_List163
Cont_after_r11_list163:
;now r11 point to the Pairs. to the list
mov qword [rbp + (4+1)*8], r11 ;the pointer to the list is right above the last must params
mov qword [rbp + (4+2)*8], SOB_NIL_ADDRESS ; magic above the list
Cont_After_Adjust163:
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: y
 mov rax, PVAR(1)
push rax

Noa170:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: null?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*2]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse164
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax
; create a const
mov rax, const_tbl+66
push rax

Noa169:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a free param: *
 mov rax, qword [fvar_tbl+ WORD_SIZE*19]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
; create a const
mov rax, const_tbl+32
push rax

Noa168:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: +
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*1]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
jmp lexit164
lelse164:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: y
 mov rax, PVAR(1)
push rax
; create a bound param: +
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*1]
push rax

Noa167:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: apply
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
; create a const
mov rax, const_tbl+66
push rax

Noa166:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a free param: *
 mov rax, qword [fvar_tbl+ WORD_SIZE*19]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa165:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: +
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*1]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
lexit164:
leave
ret
;end of the body (closure)
Lcont163:
leave
    ret
;end of the body (closure)
    Lcont162:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
mov qword[fvar_tbl+WORD_SIZE*41], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;create Def: 
;create Set for varFree >:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a free param: =
 mov rax, qword [fvar_tbl+ WORD_SIZE*21]
push rax
; create a free param: <
 mov rax, qword [fvar_tbl+ WORD_SIZE*22]
push rax
; create a free param: cdr
 mov rax, qword [fvar_tbl+ WORD_SIZE*28]
push rax
; create a free param: car
 mov rax, qword [fvar_tbl+ WORD_SIZE*27]
push rax
; create a free param: not
 mov rax, qword [fvar_tbl+ WORD_SIZE*40]
push rax
; create a free param: null?
 mov rax, qword [fvar_tbl+ WORD_SIZE*4]
push rax

Noa171:
mov r10, 6;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple first layer:
    MAKE_CLOSURE(rax,  SOB_NIL_ADDRESS, Lcode172)
    ;jump beyond the Body
    jmp Lcont172
    Lcode172:
    push rbp
    mov rbp, rsp
    ;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a const
mov rax, const_tbl+23
push rax

Noa173:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*2
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking174:
mov rcx, 0 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env174 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop174:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop174
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env174:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1174:
cmp rcx, 0
je Continue_Allocate_Closure_Object174
check2174:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop174:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop174
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object174:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode174)
;jump beyond the Body
jmp Lcont174
Lcode174:
push rbp
mov rbp, rsp
;create a seq:
;create Set for varParam >-loop:
;create a Box:
MALLOC r8, WORD_SIZE
; create a varParam: >-loop
 mov rax, PVAR(0)

mov qword [r8], rax
mov rax, r8
mov PVAR(0), rax
 mov rax, SOB_VOID_ADDRESS
;create BoxSet :
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking175:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env175 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop175:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop175
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env175:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1175:
cmp rcx, 0
je Continue_Allocate_Closure_Object175
check2175:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop175:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop175
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object175:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode175)
;jump beyond the Body
jmp Lcont175
Lcode175:
push rbp
mov rbp, rsp
;create Or:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: ys
 mov rax, PVAR(1)
push rax

Noa188:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: null?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
jne lexit176
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: ys
 mov rax, PVAR(1)
push rax

Noa187:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: car
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*2]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa186:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: <
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*4]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa185:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: not
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*1]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse177
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: ys
 mov rax, PVAR(1)
push rax

Noa184:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: car
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*2]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa183:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: =
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*5]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa182:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: not
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*1]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse178
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: ys
 mov rax, PVAR(1)
push rax

Noa181:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: cdr
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*3]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: ys
 mov rax, PVAR(1)
push rax

Noa180:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: car
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*2]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa179:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create BoxGet :
; create a bound param: >-loop
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]
mov rax, qword[rax]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
jmp lexit178
lelse178:
; create a const
mov rax, const_tbl+2
lexit178:
jmp lexit177
lelse177:
; create a const
mov rax, const_tbl+2
lexit177:
lexit176:

leave
ret
;end of the body (closure)
Lcont175:
push rax
; create a varParam: >-loop
 mov rax, PVAR(0)
pop qword[rax]
mov rax, SOB_VOID_ADDRESS
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic

Noa189:
mov r10, 0;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking190:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env190 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop190:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop190
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env190:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1190:
cmp rcx, 0
je Continue_Allocate_Closure_Object190
check2190:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop190:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop190
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object190:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode190)
;jump beyond the Body
jmp Lcont190
Lcode190:
push rbp
mov rbp, rsp
;create LambdaOpt multiple layers:
;code for_ext env
MALLOC rdx, WORD_SIZE*4
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking191:
mov rcx, 2 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env191 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop191:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop191
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env191:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1191:
cmp rcx, 0
je Continue_Allocate_Closure_Object191
check2191:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop191:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop191
Continue_Allocate_Closure_Object191:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode191)
;jump beyond the Body
jmp Lcont191
Lcode191:
push rbp
mov rbp, rsp
mov rbx, qword[rbp+ 8*3] ; rbp=n (num of initial params)
mov r8, 1 ; r8= num of must params
cmp rbx, r8 ;comparing the numbers of params with the number of the must params 
je Cont_After_Adjust191
;now code to adjust the params 
mov rcx, rbx ; ecx in now num of params 
sub rcx, r8; ecx now is num of iterations=> (num of params)- (num of must params)
add rbx, 3  ; 
shl rbx,  3 ; mutiply (n+3)*8-> distance from the An to rbx
mov r9, [rbp+rbx] ;r9=A0
mov r10, [rbp+rbx+WORD_SIZE] ;r10 holds the magic
MAKE_PAIR(r11, r9, r10) ; r11 now point to the pair(An, SOB_NIl_ADDRESS
sub rcx, 1 ; one less iteraition
cmp rcx, 0
je Cont_after_r11_list191
sub rbx, WORD_SIZE
Loop_Make_List191:
;Looop invariant r11 always points to the last Pair
mov r8, r11 ; now r8 point to the last Pair
mov r9, [rbp+rbx]; r9 point to A(i-1)
MAKE_PAIR(r11, r9,r8)
sub rbx, WORD_SIZE
loop Loop_Make_List191
Cont_after_r11_list191:
;now r11 point to the Pairs. to the list
mov qword [rbp + (4+1)*8], r11 ;the pointer to the list is right above the last must params
mov qword [rbp + (4+2)*8], SOB_NIL_ADDRESS ; magic above the list
Cont_After_Adjust191:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: y
 mov rax, PVAR(1)
push rax
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa192:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create BoxGet :
; create a bound param: >-loop
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*0]
mov rax, qword[rax]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
leave
ret
;end of the body (closure)
Lcont191:

leave
ret
;end of the body (closure)
Lcont190:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic

leave
ret
;end of the body (closure)
Lcont174:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
leave
    ret
;end of the body (closure)
    Lcont172:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
mov qword[fvar_tbl+WORD_SIZE*42], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;create Def: 
;create Set for varFree gcd:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a free param: cdr
 mov rax, qword [fvar_tbl+ WORD_SIZE*28]
push rax
; create a free param: car
 mov rax, qword [fvar_tbl+ WORD_SIZE*27]
push rax
; create a free param: null?
 mov rax, qword [fvar_tbl+ WORD_SIZE*4]
push rax
; create a free param: gcd
 mov rax, qword [fvar_tbl+ WORD_SIZE*25]
push rax

Noa193:
mov r10, 4;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple first layer:
    MAKE_CLOSURE(rax,  SOB_NIL_ADDRESS, Lcode194)
    ;jump beyond the Body
    jmp Lcont194
    Lcode194:
    push rbp
    mov rbp, rsp
    ;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a const
mov rax, const_tbl+23
push rax

Noa195:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*2
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking196:
mov rcx, 0 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env196 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop196:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop196
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env196:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1196:
cmp rcx, 0
je Continue_Allocate_Closure_Object196
check2196:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop196:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop196
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object196:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode196)
;jump beyond the Body
jmp Lcont196
Lcode196:
push rbp
mov rbp, rsp
;create a seq:
;create Set for varParam gcd-loop:
;create a Box:
MALLOC r8, WORD_SIZE
; create a varParam: gcd-loop
 mov rax, PVAR(0)

mov qword [r8], rax
mov rax, r8
mov PVAR(0), rax
 mov rax, SOB_VOID_ADDRESS
;create BoxSet :
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking197:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env197 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop197:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop197
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env197:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1197:
cmp rcx, 0
je Continue_Allocate_Closure_Object197
check2197:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop197:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop197
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object197:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode197)
;jump beyond the Body
jmp Lcont197
Lcode197:
push rbp
mov rbp, rsp
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: ys
 mov rax, PVAR(1)
push rax

Noa203:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: null?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*1]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse198
; create a varParam: x
 mov rax, PVAR(0)
jmp lexit198
lelse198:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: ys
 mov rax, PVAR(1)
push rax

Noa202:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: cdr
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*3]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: ys
 mov rax, PVAR(1)
push rax

Noa201:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: car
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*2]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa200:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: gcd
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa199:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create BoxGet :
; create a bound param: gcd-loop
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]
mov rax, qword[rax]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
lexit198:

leave
ret
;end of the body (closure)
Lcont197:
push rax
; create a varParam: gcd-loop
 mov rax, PVAR(0)
pop qword[rax]
mov rax, SOB_VOID_ADDRESS
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic

Noa204:
mov r10, 0;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking205:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env205 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop205:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop205
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env205:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1205:
cmp rcx, 0
je Continue_Allocate_Closure_Object205
check2205:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop205:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop205
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object205:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode205)
;jump beyond the Body
jmp Lcont205
Lcode205:
push rbp
mov rbp, rsp
;create LambdaOpt multiple layers:
;code for_ext env
MALLOC rdx, WORD_SIZE*4
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking206:
mov rcx, 2 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env206 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop206:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop206
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env206:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1206:
cmp rcx, 0
je Continue_Allocate_Closure_Object206
check2206:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop206:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop206
Continue_Allocate_Closure_Object206:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode206)
;jump beyond the Body
jmp Lcont206
Lcode206:
push rbp
mov rbp, rsp
mov rbx, qword[rbp+ 8*3] ; rbp=n (num of initial params)
mov r8, 0 ; r8= num of must params
cmp rbx, r8 ;comparing the numbers of params with the number of the must params 
je Cont_After_Adjust206
;now code to adjust the params 
mov rcx, rbx ; ecx in now num of params 
sub rcx, r8; ecx now is num of iterations=> (num of params)- (num of must params)
add rbx, 3  ; 
shl rbx,  3 ; mutiply (n+3)*8-> distance from the An to rbx
mov r9, [rbp+rbx] ;r9=A0
mov r10, [rbp+rbx+WORD_SIZE] ;r10 holds the magic
MAKE_PAIR(r11, r9, r10) ; r11 now point to the pair(An, SOB_NIl_ADDRESS
sub rcx, 1 ; one less iteraition
cmp rcx, 0
je Cont_after_r11_list206
sub rbx, WORD_SIZE
Loop_Make_List206:
;Looop invariant r11 always points to the last Pair
mov r8, r11 ; now r8 point to the last Pair
mov r9, [rbp+rbx]; r9 point to A(i-1)
MAKE_PAIR(r11, r9,r8)
sub rbx, WORD_SIZE
loop Loop_Make_List206
Cont_after_r11_list206:
;now r11 point to the Pairs. to the list
mov qword [rbp + (4+0)*8], r11 ;the pointer to the list is right above the last must params
mov qword [rbp + (4+1)*8], SOB_NIL_ADDRESS ; magic above the list
Cont_After_Adjust206:
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa211:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: null?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*2]
 mov rax, qword[rax+ 8*1]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse207
; create a const
mov rax, const_tbl+32
jmp lexit207
lelse207:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa210:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: cdr
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*2]
 mov rax, qword[rax+ 8*3]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa209:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: car
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*2]
 mov rax, qword[rax+ 8*2]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa208:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create BoxGet :
; create a bound param: gcd-loop
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*0]
mov rax, qword[rax]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
lexit207:
leave
ret
;end of the body (closure)
Lcont206:

leave
ret
;end of the body (closure)
Lcont205:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic

leave
ret
;end of the body (closure)
Lcont196:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
leave
    ret
;end of the body (closure)
    Lcont194:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
mov qword[fvar_tbl+WORD_SIZE*25], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;create Def: 
;create Set for varFree zero?:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a free param: =
 mov rax, qword [fvar_tbl+ WORD_SIZE*21]
push rax

Noa212:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple first layer:
    MAKE_CLOSURE(rax,  SOB_NIL_ADDRESS, Lcode213)
    ;jump beyond the Body
    jmp Lcont213
    Lcode213:
    push rbp
    mov rbp, rsp
    ;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*2
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking214:
mov rcx, 0 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env214 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop214:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop214
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env214:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1214:
cmp rcx, 0
je Continue_Allocate_Closure_Object214
check2214:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop214:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop214
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object214:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode214)
;jump beyond the Body
jmp Lcont214
Lcode214:
push rbp
mov rbp, rsp
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a const
mov rax, const_tbl+32
push rax
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa215:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: =
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic

leave
ret
;end of the body (closure)
Lcont214:
leave
    ret
;end of the body (closure)
    Lcont213:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
mov qword[fvar_tbl+WORD_SIZE*43], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;create Def: 
;create Set for varFree integer?:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a free param: denominator
 mov rax, qword [fvar_tbl+ WORD_SIZE*24]
push rax
; create a free param: =
 mov rax, qword [fvar_tbl+ WORD_SIZE*21]
push rax
; create a free param: rational?
 mov rax, qword [fvar_tbl+ WORD_SIZE*2]
push rax

Noa216:
mov r10, 3;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple first layer:
    MAKE_CLOSURE(rax,  SOB_NIL_ADDRESS, Lcode217)
    ;jump beyond the Body
    jmp Lcont217
    Lcode217:
    push rbp
    mov rbp, rsp
    ;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*2
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking218:
mov rcx, 0 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env218 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop218:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop218
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env218:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1218:
cmp rcx, 0
je Continue_Allocate_Closure_Object218
check2218:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop218:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop218
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object218:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode218)
;jump beyond the Body
jmp Lcont218
Lcode218:
push rbp
mov rbp, rsp
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa222:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: rational?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse219
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a const
mov rax, const_tbl+49
push rax
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa221:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: denominator
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*2]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa220:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: =
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*1]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
jmp lexit219
lelse219:
; create a const
mov rax, const_tbl+2
lexit219:

leave
ret
;end of the body (closure)
Lcont218:
leave
    ret
;end of the body (closure)
    Lcont217:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
mov qword[fvar_tbl+WORD_SIZE*44], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;create Def: 
;create Set for varFree number?:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a free param: rational?
 mov rax, qword [fvar_tbl+ WORD_SIZE*2]
push rax
; create a free param: flonum?
 mov rax, qword [fvar_tbl+ WORD_SIZE*1]
push rax

Noa223:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple first layer:
    MAKE_CLOSURE(rax,  SOB_NIL_ADDRESS, Lcode224)
    ;jump beyond the Body
    jmp Lcont224
    Lcode224:
    push rbp
    mov rbp, rsp
    ;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*2
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking225:
mov rcx, 0 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env225 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop225:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop225
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env225:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1225:
cmp rcx, 0
je Continue_Allocate_Closure_Object225
check2225:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop225:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop225
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object225:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode225)
;jump beyond the Body
jmp Lcont225
Lcode225:
push rbp
mov rbp, rsp
;create Or:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa228:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: flonum?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
jne lexit226
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa227:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: rational?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*1]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
lexit226:

leave
ret
;end of the body (closure)
Lcont225:
leave
    ret
;end of the body (closure)
    Lcont224:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
mov qword[fvar_tbl+WORD_SIZE*45], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;create Def: 
;create Set for varFree length:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a free param: +
 mov rax, qword [fvar_tbl+ WORD_SIZE*18]
push rax
; create a free param: fold-left
 mov rax, qword [fvar_tbl+ WORD_SIZE*33]
push rax

Noa229:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple first layer:
    MAKE_CLOSURE(rax,  SOB_NIL_ADDRESS, Lcode230)
    ;jump beyond the Body
    jmp Lcont230
    Lcode230:
    push rbp
    mov rbp, rsp
    ;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*2
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking231:
mov rcx, 0 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env231 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop231:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop231
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env231:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1231:
cmp rcx, 0
je Continue_Allocate_Closure_Object231
check2231:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop231:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop231
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object231:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode231)
;jump beyond the Body
jmp Lcont231
Lcode231:
push rbp
mov rbp, rsp
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: l
 mov rax, PVAR(0)
push rax
; create a const
mov rax, const_tbl+32
push rax
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking233:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env233 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop233:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop233
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env233:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1233:
cmp rcx, 0
je Continue_Allocate_Closure_Object233
check2233:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop233:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop233
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object233:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode233)
;jump beyond the Body
jmp Lcont233
Lcode233:
push rbp
mov rbp, rsp
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a const
mov rax, const_tbl+49
push rax
; create a varParam: acc
 mov rax, PVAR(0)
push rax

Noa234:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: +
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*1]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic

leave
ret
;end of the body (closure)
Lcont233:
push rax

Noa232:
mov r10, 3;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: fold-left
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic

leave
ret
;end of the body (closure)
Lcont231:
leave
    ret
;end of the body (closure)
    Lcont230:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
mov qword[fvar_tbl+WORD_SIZE*46], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;create Def: 
;create Set for varFree string->list:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a free param: cons
 mov rax, qword [fvar_tbl+ WORD_SIZE*29]
push rax
; create a free param: -
 mov rax, qword [fvar_tbl+ WORD_SIZE*41]
push rax
; create a free param: <
 mov rax, qword [fvar_tbl+ WORD_SIZE*22]
push rax
; create a free param: string-length
 mov rax, qword [fvar_tbl+ WORD_SIZE*9]
push rax
; create a free param: string-ref
 mov rax, qword [fvar_tbl+ WORD_SIZE*10]
push rax

Noa235:
mov r10, 5;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple first layer:
    MAKE_CLOSURE(rax,  SOB_NIL_ADDRESS, Lcode236)
    ;jump beyond the Body
    jmp Lcont236
    Lcode236:
    push rbp
    mov rbp, rsp
    ;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*2
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking237:
mov rcx, 0 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env237 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop237:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop237
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env237:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1237:
cmp rcx, 0
je Continue_Allocate_Closure_Object237
check2237:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop237:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop237
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object237:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode237)
;jump beyond the Body
jmp Lcont237
Lcode237:
push rbp
mov rbp, rsp
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a const
mov rax, const_tbl+23
push rax

Noa238:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking239:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env239 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop239:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop239
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env239:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1239:
cmp rcx, 0
je Continue_Allocate_Closure_Object239
check2239:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop239:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop239
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object239:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode239)
;jump beyond the Body
jmp Lcont239
Lcode239:
push rbp
mov rbp, rsp
;create a seq:
;create Set for varParam s->l-loop:
;create a Box:
MALLOC r8, WORD_SIZE
; create a varParam: s->l-loop
 mov rax, PVAR(0)

mov qword [r8], rax
mov rax, r8
mov PVAR(0), rax
 mov rax, SOB_VOID_ADDRESS
;create BoxSet :
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*4
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking240:
mov rcx, 2 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env240 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop240:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop240
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env240:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1240:
cmp rcx, 0
je Continue_Allocate_Closure_Object240
check2240:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop240:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop240
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object240:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode240)
;jump beyond the Body
jmp Lcont240
Lcode240:
push rbp
mov rbp, rsp
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a const
mov rax, const_tbl+32
push rax
; create a varParam: n
 mov rax, PVAR(0)
push rax

Noa246:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: <
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*2]
 mov rax, qword[rax+ 8*2]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse241
; create a varParam: a
 mov rax, PVAR(1)
jmp lexit241
lelse241:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: a
 mov rax, PVAR(1)
push rax
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: n
 mov rax, PVAR(0)
push rax
; create a bound param: s
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*0]
push rax

Noa245:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: string-ref
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*2]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa244:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: cons
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*2]
 mov rax, qword[rax+ 8*4]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a const
mov rax, const_tbl+49
push rax
; create a varParam: n
 mov rax, PVAR(0)
push rax

Noa243:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: -
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*2]
 mov rax, qword[rax+ 8*3]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa242:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create BoxGet :
; create a bound param: s->l-loop
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]
mov rax, qword[rax]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
lexit241:

leave
ret
;end of the body (closure)
Lcont240:
push rax
; create a varParam: s->l-loop
 mov rax, PVAR(0)
pop qword[rax]
mov rax, SOB_VOID_ADDRESS
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic

Noa247:
mov r10, 0;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*4
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking248:
mov rcx, 2 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env248 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop248:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop248
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env248:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1248:
cmp rcx, 0
je Continue_Allocate_Closure_Object248
check2248:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop248:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop248
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object248:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode248)
;jump beyond the Body
jmp Lcont248
Lcode248:
push rbp
mov rbp, rsp
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a const
mov rax, const_tbl+1
push rax
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a const
mov rax, const_tbl+49
push rax
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a bound param: s
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*0]
push rax

Noa251:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: string-length
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*2]
 mov rax, qword[rax+ 8*1]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa250:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: -
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*2]
 mov rax, qword[rax+ 8*3]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa249:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create BoxGet :
; create a bound param: s->l-loop
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]
mov rax, qword[rax]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic

leave
ret
;end of the body (closure)
Lcont248:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic

leave
ret
;end of the body (closure)
Lcont239:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic

leave
ret
;end of the body (closure)
Lcont237:
leave
    ret
;end of the body (closure)
    Lcont236:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
mov qword[fvar_tbl+WORD_SIZE*47], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;create Def: 
;create Set for varFree equal?:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a free param: char->integer
 mov rax, qword [fvar_tbl+ WORD_SIZE*14]
push rax
; create a free param: cdr
 mov rax, qword [fvar_tbl+ WORD_SIZE*28]
push rax
; create a free param: car
 mov rax, qword [fvar_tbl+ WORD_SIZE*27]
push rax
; create a free param: eq?
 mov rax, qword [fvar_tbl+ WORD_SIZE*17]
push rax
; create a free param: string?
 mov rax, qword [fvar_tbl+ WORD_SIZE*6]
push rax
; create a free param: char?
 mov rax, qword [fvar_tbl+ WORD_SIZE*5]
push rax
; create a free param: pair?
 mov rax, qword [fvar_tbl+ WORD_SIZE*3]
push rax
; create a free param: flonum?
 mov rax, qword [fvar_tbl+ WORD_SIZE*1]
push rax
; create a free param: rational?
 mov rax, qword [fvar_tbl+ WORD_SIZE*2]
push rax
; create a free param: string->list
 mov rax, qword [fvar_tbl+ WORD_SIZE*47]
push rax
; create a free param: =
 mov rax, qword [fvar_tbl+ WORD_SIZE*21]
push rax

Noa252:
mov r10, 11;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple first layer:
    MAKE_CLOSURE(rax,  SOB_NIL_ADDRESS, Lcode253)
    ;jump beyond the Body
    jmp Lcont253
    Lcode253:
    push rbp
    mov rbp, rsp
    ;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a const
mov rax, const_tbl+23
push rax

Noa254:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*2
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking255:
mov rcx, 0 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env255 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop255:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop255
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env255:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1255:
cmp rcx, 0
je Continue_Allocate_Closure_Object255
check2255:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop255:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop255
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object255:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode255)
;jump beyond the Body
jmp Lcont255
Lcode255:
push rbp
mov rbp, rsp
;create a seq:
;create Set for varParam equal?-loop:
;create a Box:
MALLOC r8, WORD_SIZE
; create a varParam: equal?-loop
 mov rax, PVAR(0)

mov qword [r8], rax
mov rax, r8
mov PVAR(0), rax
 mov rax, SOB_VOID_ADDRESS
;create BoxSet :
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking256:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env256 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop256:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop256
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env256:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1256:
cmp rcx, 0
je Continue_Allocate_Closure_Object256
check2256:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop256:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop256
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object256:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode256)
;jump beyond the Body
jmp Lcont256
Lcode256:
push rbp
mov rbp, rsp
;create If:
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa292:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: rational?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*2]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse290
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: y
 mov rax, PVAR(1)
push rax

Noa291:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: rational?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*2]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
jmp lexit290
lelse290:
; create a const
mov rax, const_tbl+2
lexit290:
cmp rax, SOB_FALSE_ADDRESS
je lelse257
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: y
 mov rax, PVAR(1)
push rax
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa289:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: =
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
jmp lexit257
lelse257:
;create If:
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa288:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: flonum?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*3]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse286
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: y
 mov rax, PVAR(1)
push rax

Noa287:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: flonum?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*3]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
jmp lexit286
lelse286:
; create a const
mov rax, const_tbl+2
lexit286:
cmp rax, SOB_FALSE_ADDRESS
je lelse258
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: y
 mov rax, PVAR(1)
push rax
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa285:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: =
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
jmp lexit258
lelse258:
;create If:
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa284:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: char?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*5]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse282
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: y
 mov rax, PVAR(1)
push rax

Noa283:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: char?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*5]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
jmp lexit282
lelse282:
; create a const
mov rax, const_tbl+2
lexit282:
cmp rax, SOB_FALSE_ADDRESS
je lelse259
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: y
 mov rax, PVAR(1)
push rax

Noa281:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: char->integer
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*10]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa280:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: char->integer
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*10]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa279:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: =
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
jmp lexit259
lelse259:
;create If:
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa278:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: pair?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*4]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse276
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: y
 mov rax, PVAR(1)
push rax

Noa277:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: pair?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*4]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
jmp lexit276
lelse276:
; create a const
mov rax, const_tbl+2
lexit276:
cmp rax, SOB_FALSE_ADDRESS
je lelse260
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: y
 mov rax, PVAR(1)
push rax

Noa275:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: car
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*8]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa274:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: car
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*8]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa273:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create BoxGet :
; create a bound param: equal?-loop
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]
mov rax, qword[rax]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse269
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: y
 mov rax, PVAR(1)
push rax

Noa272:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: cdr
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*9]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa271:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: cdr
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*9]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa270:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create BoxGet :
; create a bound param: equal?-loop
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]
mov rax, qword[rax]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
jmp lexit269
lelse269:
; create a const
mov rax, const_tbl+2
lexit269:
jmp lexit260
lelse260:
;create If:
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa268:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: string?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*6]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse266
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: y
 mov rax, PVAR(1)
push rax

Noa267:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: string?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*6]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
jmp lexit266
lelse266:
; create a const
mov rax, const_tbl+2
lexit266:
cmp rax, SOB_FALSE_ADDRESS
je lelse261
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: y
 mov rax, PVAR(1)
push rax

Noa265:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: string->list
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*1]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa264:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: string->list
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*1]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa263:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create BoxGet :
; create a bound param: equal?-loop
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]
mov rax, qword[rax]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
jmp lexit261
lelse261:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: y
 mov rax, PVAR(1)
push rax
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa262:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: eq?
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*1]
 mov rax, qword[rax+ 8*7]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
lexit261:
lexit260:
lexit259:
lexit258:
lexit257:

leave
ret
;end of the body (closure)
Lcont256:
push rax
; create a varParam: equal?-loop
 mov rax, PVAR(0)
pop qword[rax]
mov rax, SOB_VOID_ADDRESS
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic

Noa293:
mov r10, 0;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*3
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking294:
mov rcx, 1 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env294 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop294:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop294
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env294:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1294:
cmp rcx, 0
je Continue_Allocate_Closure_Object294
check2294:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop294:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop294
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object294:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode294)
;jump beyond the Body
jmp Lcont294
Lcode294:
push rbp
mov rbp, rsp
;create BoxGet :
; create a bound param: equal?-loop
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]
mov rax, qword[rax]

leave
ret
;end of the body (closure)
Lcont294:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic

leave
ret
;end of the body (closure)
Lcont255:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
leave
    ret
;end of the body (closure)
    Lcont253:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
mov qword[fvar_tbl+WORD_SIZE*48], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;create Def: 
;create Set for varFree d:
;create LambdaOpt first layer:
MAKE_CLOSURE(rax,  SOB_NIL_ADDRESS, Lcode295)
;jump beyond the Body
jmp Lcont295
Lcode295:
push rbp
mov rbp, rsp
mov rbx, qword[rbp+ 8*3] ; rbp=n (num of initial params)
mov r8, 0 ; r8= num of must params
cmp rbx, r8 ;comparing the numbers of params with the number of the must params 
je Cont_After_Adjust295
;now code to adjust the params 
mov rcx, rbx ; ecx in now num of params 
sub rcx, r8; ecx now is num of iterations=> (num of params)- (num of must params)
add rbx, 3  ; 
shl rbx,  3 ; mutiply (n+3)*8-> distance from the An to rbx
mov r9, [rbp+rbx] ;r9=A0
mov r10, [rbp+rbx+WORD_SIZE] ;r10 holds the magic
MAKE_PAIR(r11, r9, r10) ; r11 now point to the pair(An, SOB_NIl_ADDRESS
sub rcx, 1 ; one less iteraition
cmp rcx, 0
je Continue_List_ready295
sub rbx, WORD_SIZE
Loop_Make_List295:
;Looop invariant r11 always points to the last Pair
mov r8, r11 ; now r8 point to the last Pair
mov r9, [rbp+rbx]; r9 point to A(i-1)
MAKE_PAIR(r11, r9,r8)
sub rbx, WORD_SIZE
loop Loop_Make_List295
Continue_List_ready295:
;now r11 point to the Pairs. to the list
mov qword [rbp + (4+0)*8], r11 ;the pointer to the list is right above the last must params
mov qword [rbp + (4+1)*8], SOB_NIL_ADDRESS ; magic above the list
Cont_After_Adjust295:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a varParam: x
 mov rax, PVAR(0)
push rax
; create a varParam: x
 mov rax, PVAR(0)
push rax

Noa296:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a free param: cons
 mov rax, qword [fvar_tbl+ WORD_SIZE*29]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
leave
ret
;end of the body (closure)
Lcont295:
mov qword[fvar_tbl+WORD_SIZE*49], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create LambdaSimple first layer:
    MAKE_CLOSURE(rax,  SOB_NIL_ADDRESS, Lcode308)
    ;jump beyond the Body
    jmp Lcont308
    Lcode308:
    push rbp
    mov rbp, rsp
    ;create a seq:
; create a free param: a
 mov rax, qword [fvar_tbl+ WORD_SIZE*50]
; create a varParam: x
 mov rax, PVAR(0)
leave
    ret
;end of the body (closure)
    Lcont308:
push rax

Noa297:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple first layer:
    MAKE_CLOSURE(rax,  SOB_NIL_ADDRESS, Lcode298)
    ;jump beyond the Body
    jmp Lcont298
    Lcode298:
    push rbp
    mov rbp, rsp
    ;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic

Noa307:
mov r10, 0;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a free param: d
 mov rax, qword [fvar_tbl+ WORD_SIZE*49]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa299:
mov r10, 1;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
;create LambdaSimple multiple layers
;code for_ext env
MALLOC rdx, WORD_SIZE*2
; store old env in rbx 
mov rbx, qword[rbp+ 8*2]
mov r8, rdx ;store 0 index of the ext_env
add rdx, WORD_SIZE ;rdx now point to index 1 ext env
checking300:
mov rcx, 0 ; numbers of loops 
cmp rcx, 0
je Continue_Ext_Env300 ;if (the depth-1) is 0 then thres nothing to copy besides paramsn
Copy_Ext_Env_Loop300:
mov r10, qword[rbx]
mov [rdx], r10 ; now extEnv[i+1]= oldEnv[i]
add rbx, WORD_SIZE ; add 8 to the next vector oldEnv
add rdx, WORD_SIZE ; add 8 to the next vector extEnv
loop Copy_Ext_Env_Loop300
;now code to copy the old env Params to extEnv index 0
Continue_Ext_Env300:
mov rdx, r8 ;restore index 0
mov qword[rdx], SOB_NIL_ADDRESS ;just in case n==0
mov rcx, qword[rbp+ 8*3] ;rcx=n (num of params)
check1300:
cmp rcx, 0
je Continue_Allocate_Closure_Object300
check2300:
mov r11, rcx ;keep rcx unchanged
shl r11,  3 ; mutiply n*8-> number of bytes to allocate
add r11, 1 ; saving space for the magic
MALLOC r10, r11 ;allocating memory for index 0 in extEnv
mov [rdx], r10 ; now ext env 0 pointing to the allocated memory
mov rdx, r10 ; rdx is the start of allocated memory' the atcual vector of ext env 0
mov r14, 32 ; 8*4-> qwors[rbp+ 8*4]=A0
Copy_Params_Ext_Env_Loop300:
mov rbx, qword[rbp+r14] ; rbx= A0
mov [rdx], rbx ; Ai -> extEnx[0][i] 
add r14, WORD_SIZE
add rdx, WORD_SIZE
loop Copy_Params_Ext_Env_Loop300
mov qword[rdx], SOB_NIL_ADDRESS ; magic at the and of extEnv 0
Continue_Allocate_Closure_Object300:
; done with extending the env. now making closure
MAKE_CLOSURE(rax,  r8, Lcode300)
;jump beyond the Body
jmp Lcont300
Lcode300:
push rbp
mov rbp, rsp
;create If:
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a const
mov rax, const_tbl+93
push rax
; create a const
mov rax, const_tbl+4
push rax

Noa306:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a bound param: a
 mov rax, qword [rbp + 8*2]
mov rax, qword[rax + 8*0]
 mov rax, qword[rax+ 8*0]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
cmp rax, SOB_FALSE_ADDRESS
je lelse301
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a const
mov rax, const_tbl+1
push rax
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
;create Applic:
push SOB_NIL_ADDRESS ; pushing magic
; create a const
mov rax, const_tbl+1
push rax
; create a const
mov rax, const_tbl+93
push rax

Noa305:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a free param: cons
 mov rax, qword [fvar_tbl+ WORD_SIZE*29]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
; create a const
mov rax, const_tbl+93
push rax

Noa304:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a free param: cons
 mov rax, qword [fvar_tbl+ WORD_SIZE*29]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax

Noa303:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a free param: cons
 mov rax, qword [fvar_tbl+ WORD_SIZE*29]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
push rax
; create a varParam: c
 mov rax, PVAR(0)
push rax

Noa302:
mov r10, 2;r10 now holds n (num of params)
push r10 ;pushing n (num of params)
;generating the proc. should be a closure
; create a free param: append
 mov rax, qword [fvar_tbl+ WORD_SIZE*37]

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
jmp lexit301
lelse301:
; create a const
mov rax, const_tbl+0
lexit301:

leave
ret
;end of the body (closure)
Lcont300:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic
leave
    ret
;end of the body (closure)
    Lcont298:

push qword[rax+TYPE_SIZE]
call [rax+TYPE_SIZE+WORD_SIZE]
add rsp, 8*1 ; pop env
pop rbx ; pop arg count
shl rbx, 3 ; rbx = rbx * 8
add rsp, rbx; pop args
add rsp, 8; poping magic

	call write_sob_if_not_void;;; Clean up the dummy frame, set the exit status to 0 ("success"), 
   ;;; and return from main
   pop rbp
   add rsp, 3*8
   mov rax, 0

   ret
boolean?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_BOOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

flonum?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_FLOAT
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

rational?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_RATIONAL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

pair?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_PAIR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

null?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_NIL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CHAR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_STRING
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

symbol?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_SYMBOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

procedure?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CLOSURE
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

div:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .div_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  divsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .div_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          MAKE_RATIONAL(rax, rdx, rdi)
         mov PVAR(1), rax
         pop rbp
         jmp mul
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

mul:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .mul_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  mulsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .mul_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdi
	 imul rcx, rdx
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

add:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .add_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  addsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .add_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdx
	 imul rdi, rcx
	 add rsi, rdi
	 imul rcx, rdx
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

eq:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .eq_rat
             FLOAT_VAL rsi, rsi
	 FLOAT_VAL rdi, rdi
	 cmp rsi, rdi
             jmp .op_return
          .eq_rat:
             NUMERATOR rcx, rsi
	 NUMERATOR rdx, rdi
	 cmp rcx, rdx
	 jne .false
	 DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 cmp rcx, rdx
         .false:
          .op_return:
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

lt:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .lt_rat
             FLOAT_VAL rsi, rsi
	 movq xmm0, rsi
	 FLOAT_VAL rdi, rdi
	 movq xmm1, rdi
	 cmpltpd xmm0, xmm1
         movq rsi, xmm0
         cmp rsi, 0
             jmp .op_return
          .lt_rat:
             DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 NUMERATOR rsi, rsi
	 NUMERATOR rdi, rdi
	 imul rsi, rdx
	 imul rdi, rcx
	 cmp rsi, rdi
          .op_return:
      jl .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string_length:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	STRING_LENGTH rsi, rsi
         MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

string_ref:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         mov sil, byte [rsi]
         MAKE_CHAR(rax, sil)
         pop rbp
         ret

string_set:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov rdx, PVAR(2)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         CHAR_VAL rax, rdx
         mov byte [rsi], al
         mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

make_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	NUMERATOR rsi, rsi
         CHAR_VAL rdi, rdi
         and rdi, 255
         MAKE_STRING rax, rsi, dil
         pop rbp
         ret

symbol_to_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	SYMBOL_VAL rsi, rsi
	 STRING_LENGTH rcx, rsi
	 STRING_ELEMENTS rdi, rsi
	 push rcx
	 push rdi
	 mov dil, byte [rdi]
	 MAKE_CHAR(rax, dil)
	 push rax
	 MAKE_RATIONAL(rax, rcx, 1)
	 push rax
	 push 2
	 push SOB_NIL_ADDRESS
	 call make_string
	 add rsp, 4*8
	 STRING_ELEMENTS rsi, rax   
	 pop rdi
	 pop rcx
	 cmp rcx, 0
	 je .end
         .loop:
	 lea r8, [rdi+rcx]
	 lea r9, [rsi+rcx]
	 mov bl, byte [r8]
	 mov byte [r9], bl
	 loop .loop
         .end:
         pop rbp
         ret

eq?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	cmp rsi, rdi
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char_to_integer:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CHAR_VAL rsi, rsi
	 and rsi, 255
	 MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

integer_to_char:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 and rsi, 255
	 MAKE_CHAR(rax, sil)
         pop rbp
         ret

exact_to_inexact:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rdi, rsi
	 NUMERATOR rsi, rsi 
	 cvtsi2sd xmm0, rsi
	 cvtsi2sd xmm1, rdi
	 divsd xmm0, xmm1
	 movq rsi, xmm0
	 MAKE_FLOAT(rax, rsi)
         pop rbp
         ret

numerator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

denominator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

gcd:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	xor rdx, rdx
	 NUMERATOR rax, rsi
         NUMERATOR rdi, rdi
         .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	 mov rdx, rax
         cmp rdx, 0
         jge .make_result
         neg rdx
         .make_result:
         MAKE_RATIONAL(rax, rdx, 1)
         pop rbp
         ret

car:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CAR rax, rsi
         pop rbp
         ret

cdr:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CDR rax, rsi
         pop rbp
         ret

set_car:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	lea rsi, [rsi+TYPE_SIZE]
      mov qword[rsi], rdi
      mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

set_cdr:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	lea rsi, [rsi+TYPE_SIZE+WORD_SIZE]
      mov qword[rsi], rdi
      mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

cons:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	MAKE_PAIR(rax, rsi, rdi)
         pop rbp
         ret

apply:
       push rbp
       mov rbp, rsp 
       push SOB_NIL_ADDRESS
      xor rcx, rcx
      xor r15, r15 
      mov r8, qword [rbp+(3)*WORD_SIZE]
      add r8, 3 
      shl r8, 3 
      mov r9, rbp
      add r9, r8  
      mov r8, [r9]
    
      cmp r8, SOB_NIL_ADDRESS
      je .push_objects
    
      .get_list_length :
        cmp r8, SOB_NIL_ADDRESS
        je .set_rsp
        inc rcx
        CDR r8, r8
        jmp .get_list_length
    
      .set_rsp:
        add r15, rcx
        shl rcx, 3 
        sub rsp, rcx
        shr rcx, 3
        mov r8, rsp  
        mov r10, [r9]
    
      .push_list_elements_loop: 
        CAR r11, r10 
        CDR r10, r10 
        mov [r8], r11 
        add r8, WORD_SIZE 
        loop .push_list_elements_loop
    
      .push_objects:
        mov rcx, qword [rbp+(3)*WORD_SIZE] 
        sub rcx, 2
        add r15, rcx
        cmp rcx, 0 
        je .done_push_objects
        mov r8, rcx
        add r8, 4
        shl r8, 3
        add r8, rbp
    
      .push_objects_loop:
        push qword [r8]
        sub r8, 8
        loop .push_objects_loop
    
      .done_push_objects:
        push r15  
        add r15, 5
        mov r12, PVAR(0)
        CLOSURE_ENV r13, r12
        push r13
        push qword [rbp+WORD_SIZE]
        mov r14, qword [rbp]
    
      .shift_frame:
        push rax
	      mov rax, qword [rbp+3*WORD_SIZE]
	      add rax, 5
	      mov r10, 1
	      mov r11, rbp
	    .apply_loop:
	      cmp r15, 0 
	      je .done_apply_loop
	      dec r15
	      dec rax
	      neg r10
	      push qword [rbp+r10*WORD_SIZE]
	      neg r10
	      inc r10
	      pop qword [rbp+rax*WORD_SIZE]
	      jmp .apply_loop
	    .done_apply_loop:
	      imul rax, WORD_SIZE	
	      add r11, rax		
	      pop rax
        mov rsp, r11
    
      mov rbp , r14
      add rsp, WORD_SIZE    
      CLOSURE_CODE r13, r12
      jmp r13      

      
         pop rbp
         ret